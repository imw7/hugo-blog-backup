+++
title='补码'
tags=['补码']
categories=['Go', 'C/C++']
date="2024-01-10T15:39:38+08:00"
toc=true
draft=false

+++

本文的目标是理解正负数的补码，以及如何进行计算。<!--more-->

# 补码

## 什么是补码

**补码**（英语：**`2's complement`**）是一种用二进制表示有符号数的方法，也是一种将数字的正负号变号的方式，常在计算机科学中使用。补码以有符号比特的二进制数定义。
正数和`0`的补码就是该数字本身再补上最高比特`0`。负数的补码则是将其**绝对值**按位取反再加`1`。

## 补码有什么用

补码系统的最大优点是可以在**加法**或**减法**处理中，不需因为数字的正负而使用不同的计算方式。只要一种加法电路就可以处理各种有号数加法，而且减法可以用一个数加上另一个数的补码来表示，因此只要有加法电路及补码电路即可完成各种有号数加法及减法，在电路设计上相当方便。

### 已知十进制求二进制

#### 求正整数的二进制

除`2`取余，直至商为`0`，余数倒序排序。

以十进制数 `156` 为例，使用短除法：

![short division](https://blog.imw7.com/images/data_structure/2s_complement/short_division.png)

​																		*图1.短除法*

求得结果 `10011100`，即：$156_{10}=10011100_{2}$。

检验：

```c
#include <stdio.h>

int main() {
    int n = 156;
    printf("%b\n", n);
    
    return 0;
}
```

运行结果：

```bash
10011100
```

可以看到结果是相同的，所以短除法是可行的。

#### 求负整数的二进制

先求与该负数相对应的正整数的二进制代码，然后将所有位取反，末尾加`1`。不够位数时，左边补`1`，**补足`32`位**<?>。

**注**： `C` 语言在一般的电脑中，`int` 类型占用 `4` 字节，`32`比特。所以需要补齐`32`位，否则会被当做正数，自动补零处理。

以 `-156` 为例：

| 操作     | 码值                                      | 解释                             |
| -------- | ----------------------------------------- | -------------------------------- |
| 原码     | `1001 1100`                               | `156`的二进制，即原码            |
| 反码     | `0110 0011`                               | 所有位取反，即反码               |
| 补码     | `0110 0100`                               | 末尾`+1`，即反码`+1`，也就是补码 |
| 补齐32位 | `1111 1111 1111 1111 1111 1111 0110 0100` | 补齐`32`位，负数补`1`，正数补`0` |
| 十六进制 | `FFFFFF64`                                | `2`进制换算成`16`进制            |

即：$-156_{10}=11111111111111111111111101100100_{2}=FFFFFF64_{16}$。

检验：

```c
#include <stdio.h>

int main() {
    int n = -156;
    printf("%b\n", n);
    printf("%x\n", n);
    
    return 0;
}
```

运行结果：

```bash
11111111111111111111111101100100
ffffff64
```

运行结果与所求结果相同。

**注意**：正数的原码、反码和补码都一样。

#### 求零的二进制

全是`0`。

### 已知二进制求十进制

**如果首位是`0`，则表明是正整数，按普通方法来求。**

**如果首位是`1`，则表明是负整数，将所有位取反，末尾加`1`，所得数字就是该负数的绝对值。**

以负整数`10 1111`为例，高位省略了：

| 操作 | 码值      | 解释                             |
| ---- | --------- | -------------------------------- |
| 原码 | `10 1111` | 该数为负，补齐`32`位             |
| 反码 | `01 0000` | 所有位取反，即反码               |
| 补码 | `01 0001` | 末尾`+1`，即反码`+1`，也就是补码 |
| 结果 | `17`      | 所以，`10 1111`对应的负数是`-17` |

验证：

```c
#include <stdio.h>

int main() {
    printf("%d\n", 0b11111111111111111111111111101111);
    return 0;
}
```

运行结果：

```bash
-17
```

再来一个例子，求有符号二进制数`1001010`的十进制数。

```bash
原码：1001010
反码：0110101
补码：0110110
结果：54
```

所以，`1001010` 对应的十进制数为：`-54`。

验证：

```c
#include <stdio.h>

int main() {
    printf("%d\n", 0b11111111111111111111111111001010); // -54
    return 0;
}
```

**如果全是零，则对应的十进制数字就是零。**

## 8位二进制所代表的十进制

| 二进制      | 十进制 |
| ----------- | ------ |
| `0000 0000` | `0`    |
| `0000 0001` | `1`    |
| ...         | ...    |
| `0111 1111` | `127`  |
| `1000 0000` | `-128` |
| `1000 0001` | `-127` |
| ...         | ...    |
| `1111 1110` | `-2`   |
| `1111 1111` | `-1`   |

